<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../assets/CSS/Nav_Bar.css">
    <link rel="stylesheet" href="../assets/CSS/Learning_Styles.css">
    <title>User Accounts</title>
</head>

<body>
    <img src="../assets/images/bg1.jpg" alt="Cover_Image" class="Cover_Image">
    <main>
        <aside class="Sections_Tab"></aside>
        <div class="Content_Area">
            <h1 class="Chapter_Title">User Accounts</h1>
            <div class="Sections_Area">
                <section id="Defining_Models">
                    <h2 class="Section_Title">Defining Models</h2>
                    <div class="Definitions">
                        In Django, a model is a Python class that represents a database table. Each attribute of the
                        class
                        corresponds to a column in the table. Models are defined in the models.py file of your app. <br>
                        Here's an example of how to define a simple model for a User in the Accounts app. <br>
                        First, create a new file called managers.py in the Accounts app directory and add the following
                        code to
                        define a custom user manager:
                    </div>
                    <pre class="prettyprint python Code">
# accounts/managers.py

from django.contrib.auth.models import BaseUserManager

class CustomUserManager(BaseUserManager):
    def create_user(self, email, password=None, role=None, **extra_fields):
        """Create and return a regular user with an email and password."""
        if not email:
            raise ValueError("Users must have an email address")

        email = self.normalize_email(email)

        # Default role if not provided
        if role is None:
            role = self.model.STUDENT

        user = self.model(email=email, role=role, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, password=None, **extra_fields):
        """Create and return a superuser with ADMIN role."""
        extra_fields.setdefault("is_staff", True)
        extra_fields.setdefault("is_superuser", True)
        extra_fields.setdefault("is_active", True)

        if extra_fields.get("is_staff") is not True:
            raise ValueError("Superuser must have is_staff=True.")
        if extra_fields.get("is_superuser") is not True:
            raise ValueError("Superuser must have is_superuser=True.")

        return self.create_user(
            email=email,
            password=password,
            role=self.model.ADMIN,
            **extra_fields,
        )
                    </pre>
                    <div class="Definitions">
                        In this custom user manager, we define methods to create regular users and superusers with
                        specific roles. <br>
                        CustomUserManager extends BaseUserManager and provides methods to create users with email as the
                        unique identifier and assign roles.
                        This class has two main methods:
                        <ul>
                            <li><strong>create_user:</strong> This method creates a regular user with the specified
                                email, password, and role. If no role is provided, it defaults to STUDENT.</li>
                            <li><strong>create_superuser:</strong> This method creates a superuser with the ADMIN role
                                and ensures that the necessary flags (is_staff, is_superuser, is_active) are set to
                                True.</li>
                        </ul>
                        After defining the custom user manager, we can now define the User model in models.py:
                    </div>
                    <pre class="prettyprint python Code">
# accounts/models.py

from django.contrib.auth.models import AbstractUser
from django.db import models
from .managers import CustomUserManager


class User(AbstractUser):
    # We use email as the login identifier
    username = None
    email = models.EmailField(unique=True)

    # Role choices
    STUDENT = "student"
    TEACHER = "teacher"
    ADMIN = "admin"

    ROLE_CHOICES = [
        (STUDENT, "Student"),
        (TEACHER, "Teacher"),
        (ADMIN, "Admin"),
    ]

    role = models.CharField(max_length=20, choices=ROLE_CHOICES, default=STUDENT)

    phone = models.CharField(max_length=20, blank=True, null=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = []  # No username required

    objects = CustomUserManager()

    def __str__(self):
        return f"{self.email} ({self.role})"
                    </pre>
                    <div class="Definitions">
                        In this User model, we extend AbstractUser to create a custom user model with email as the
                        unique
                        identifier and a role field to distinguish between different types of users (students, teachers,
                        and
                        admins). <br>
                        The phone field allows storing an optional phone number for each user. The created_at and
                        updated_at
                        fields automatically track when a user is created and last updated. <br>
                        The USERNAME_FIELD is set to email, indicating that email will be used for authentication
                        instead
                        of
                        the default username. The REQUIRED_FIELDS list is empty because we don't require any additional
                        fields
                        for user creation. <br>
                        Finally, we assign the CustomUserManager to the objects attribute to handle
                        user
                        creation and management.
                    </div>
                    <h2 class="Subsection_Title">Profile Models</h2>
                    <div class="Definitions">
                        Next, we can define profile models for students and teachers that extend the User model. <br>
                        Create a new app:
                    </div>
                    <pre class="prettyprint python Code">
python manage.py startapp profiles
                    </pre>
                    <div class="Definitions">
                        Then, in profiles/models.py, define the StudentProfile and TeacherProfile models:
                    </div>
                    <pre class="prettyprint python Code">
class StudentProfile(models.Model):
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    student_id = models.CharField(max_length=20, blank=False, null=False)
    level = models.CharField(max_length=50, blank=True, null=True)
    group = models.CharField(max_length=50, blank=True, null=True)
    speciality = models.CharField(max_length=50, blank=True, null=True)
    department = models.CharField(max_length=100, blank=True, null=True)
    address = models.CharField(max_length=500, blank=True, null=True)

    def __str__(self):
        return f"Student Profile for {self.user.first_name}, {self.user.last_name}"


class TeacherProfile(models.Model):
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    specialization = models.CharField(max_length=100, blank=True, null=True)
    office = models.CharField(max_length=50, blank=True, null=True)
    bio = models.TextField(max_length=500, blank=True, null=True)
    rank = models.TextField(max_length=50, blank=True, null=True)
    prefix = models.TextField(max_length=5, blank=True, null=True)
    department = models.CharField(max_length=100, blank=True, null=True)

    def __str__(self):
        return f"Teacher Profile for {self.user.first_name}, {self.user.last_name}"


class AdminProfile(models.Model):
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    position = models.CharField(max_length=100, blank=True, null=True)
    office = models.CharField(max_length=50, blank=True, null=True)
    service = models.CharField(max_length=50, blank=True, null=True)
    rank = models.TextField(max_length=50, blank=True, null=True)
    department = models.CharField(max_length=100, blank=True, null=True)

    def __str__(self):
        return f"Admin Profile for {self.user.first_name}, {self.user.last_name}"
                    </pre>
                    <div class="Definitions">
                        In these profile models, we use a OneToOneField to create a one-to-one relationship with the
                        custom
                        User model. Each profile model includes additional fields specific to students and teachers.
                        <br>
                        The __str__ method provides a human-readable representation of the profile, displaying the
                        user's
                        first and last name. <br>
                        Now we need to set up signals to automatically create the appropriate profile.
                    </div>
                    <h2 class="Subsection_Title">Signals (auto-create correct profile based on role)</h2>
                    <div class="Definitions">
                        To automatically create the appropriate profile when a user is created, we'll use Django
                        signals.
                        Create a file called signals.py in the profiles app directory:
                    </div>
                    <pre class="prettyprint python Code">
                        # profiles/signals.py

from django.db.models.signals import post_save
from django.dispatch import receiver
from django.conf import settings

from .models import StudentProfile, TeacherProfile, AdminProfile

@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_user_profile(sender, instance, created, **kwargs):
    if not created:
        return

    if instance.role == instance.STUDENT:
        StudentProfile.objects.create(user=instance)

    elif instance.role == instance.TEACHER:
        TeacherProfile.objects.create(user=instance)

    elif instance.role == instance.ADMIN:
        AdminProfile.objects.create(user=instance)
                    </pre>
                    <div class="Definitions">
                        In this signals.py file, we define a signal receiver function create_user_profile that listens
                        for
                        the
                        post_save signal of the User model. When a new user is created, the function checks the user's
                        role
                        and creates the corresponding profile (StudentProfile, TeacherProfile, or AdminProfile). <br>
                        Finally, we need to connect the signals. Open the apps.py file in the profiles app directory and
                        modify it as follows:
                    </div>
                    <pre class="prettyprint python Code">
# profiles/apps.py

from django.apps import AppConfig

class ProfilesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'profiles'

    def ready(self):
        import profiles.signals
                    </pre>
                    <div class="Definitions">
                        In this modified apps.py file, we override the ready method to import the signals module when
                        the
                        app is ready. This ensures that the signal receivers are connected and will function as
                        expected. <br>
                        default_auto_field is set to 'django.db.models.BigAutoField' to specify the default type of
                        primary key field
                        to use for models in this app. <br>
                        Now, whenever a new user is created, the appropriate profile will be automatically created based
                        on the user's role.
                    </div>

                </section>
                <section id="Activating_Models">
                    <h2 class="Section_Title">Activating Models</h2>
                    <div class="Definitions">
                        To use our models, we have to tell Django to include our app in the overall
                        project. Open settings.py (in the University_Platform/University_Platform directory), and
                        you'll see a section that tells Django which apps are installed in the project:
                    </div>
                    <pre class="prettyprint python Code">
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",

    # My apps
    "Accounts",
    "profiles",
]

# Custom user model
AUTH_USER_MODEL = "Accounts.User"

                </pre>
                    <div class="Definitions">
                        Add the name of your app (accounts) to the list of installed apps. This
                        tells Django to include the models defined in the accounts app when it
                        creates the database. <br>
                        Also, set the AUTH_USER_MODEL setting to point to the custom User model
                        we defined in the accounts app. This tells Django to use our custom user model
                        instead of the default User model for authentication and user management. <br>
                    </div>
                    <h2 class="Subsection_Title">Checking the Database</h2>
                    <div class="Definitions">
                        You can check that Django has recognized your models by running the following command:
                    </div>
                    <pre class="prettyprint python Code">
python manage.py check
            </pre>
                    <div class="Definitions">
                        If everything is set up correctly, you should see the message System check
                        identified no issues (0 silenced). This indicates that Django has successfully
                        recognized your models and there are no issues with the configuration.
                    </div>
                </section>

                <section>
                    <h2 class="Section_Title">Creating the Database</h2>
                    <div class="Definitions">
                        After defining your models, you need to create and apply migrations to update the database
                        schema.
                        Migrations are a way to propagate changes made to your models into the database. To create and
                        apply
                        migrations, run the following commands (Run this from the same directory where manage.py is
                        located):
                    </div>
                    <pre class="prettyprint python Code">
python manage.py makemigrations
python manage.py migrate
            </pre>
                    <div class="Definitions">
                        Whenever we want to modify the data, we'll follow these three steps:
                        modify
                        models.py, call makemigrations, and tell Django to migrate the project. <br>
                        The makemigrations command tells Django to create new migration files based on the changes
                        detected. <br>
                        The migrate command applies those migrations to the database, updating its schema to match the
                        current state of the models.
                    </div>
                </section>
                <section id="Admin_Site">
                    <h2 class="Section_Title">Using the Admin Site</h2>
                    <div class="Definitions">
                        Django includes a built-in admin site that allows you to manage your models through a web
                        interface.
                        To use the admin site, you need to create a superuser account. Run the following command:
                    </div>
                    <pre class="prettyprint python Code">
python manage.py createsuperuser
            </pre>
                    <div class="Definitions">
                        Follow the prompts to create a username, email address, and password for the superuser account.
                        Once the superuser account is created, you can access the admin site by navigating to
                        http://localhost:8000/admin in your web browser. Log in using the superuser credentials you just
                        created. <br>
                        For our example we created a superuser with the username ESST_Admin, ESST_Admin@esst-sup.com as
                        an
                        email
                        and a simple password "123456789". <br>
                        After logging in, you'll see the admin dashboard, where you can manage your models.<br>
                    </div>
                </section>
                <section id="Registering_Model_with_Admin_Site">
                    <h2 class="Section_Title">Registering Models with the Admin Site</h2>
                    <div class="Definitions">
                        To manage your models through the admin site, you need to register them in the admin.py file of
                        your
                        app. Open admin.py in the Accounts app directory and add the following code to register the User
                        model:
                    </div>
                    <pre class="prettyprint python Code">
from django.contrib import admin
from .models import User


# Register your models here.
admin.site.register(User)

            </pre>
                </section>
                <section>
                    <h2 class="Section_Title">Create admin classes for each profile</h2>
                    <div class="Definitions">
                        To manage your profile models through the admin site, you need to create admin classes in the
                        admin.py
                        file of the profiles app. Open profiles/admin.py and add the following code to register the
                        profile
                        models:
                    </div>
                    <pre class="prettyprint python Code">
# profiles/admin.py

from django.contrib import admin
from .models import StudentProfile, TeacherProfile, AdminProfile


@admin.register(StudentProfile)
class StudentProfileAdmin(admin.ModelAdmin):
    list_display = ("user", "student_id", "level", "group")
    search_fields = ("user__email", "student_id")


@admin.register(TeacherProfile)
class TeacherProfileAdmin(admin.ModelAdmin):
    list_display = ("user", "specialization", "grade", "office")
    search_fields = ("user__email", "specialization")


@admin.register(AdminProfile)
class AdminProfileAdmin(admin.ModelAdmin):
    list_display = ("user", "position", "department")
    search_fields = ("user__email", "position")
                    </pre>
                    <div class="Definitions">
                        In this admin.py file, we define admin classes for each profile model (StudentProfile,
                        TeacherProfile,
                        and AdminProfile) using the @admin.register decorator. Each admin class specifies how the
                        corresponding
                        model should be displayed in the admin interface, including the fields to display in the list
                        view
                        (list_display) and the fields to search (search_fields). <br>
                        With these admin classes in place, you can now manage student, teacher, and admin profiles
                        through
                        the Django admin site.
                    </div>
                </section>
                <section>
                    <h2 class="Section_Title">Add profile inlines to the User admin</h2>
                    <div class="Definitions">
                        To display the profile information directly within the User admin interface, we can use inline
                        models.
                        Modify the admin.py file in the Accounts app directory as follows:
                    </div>
                    <pre class="prettyprint python Code">
# accounts/admin.py

from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.forms import TextInput, Textarea

from .models import User
from profiles.models import StudentProfile, TeacherProfile, AdminProfile


class StudentProfileInline(admin.StackedInline):
    model = StudentProfile
    can_delete = False
    verbose_name_plural = "Student Profile"
    fk_name = "user"


class TeacherProfileInline(admin.StackedInline):
    model = TeacherProfile
    can_delete = False
    verbose_name_plural = "Teacher Profile"
    fk_name = "user"


class AdminProfileInline(admin.StackedInline):
    model = AdminProfile
    can_delete = False
    verbose_name_plural = "Admin Profile"
    fk_name = "user"


class UserAdmin(BaseUserAdmin):
    model = User
    list_display = ("email", "role", "is_staff", "is_active")
    list_filter = ("role", "is_staff", "is_active")

    fieldsets = (
        (None, {"fields": ("email", "password")}),
        ("Personal Info", {"fields": ("phone",)}),
        ("Role", {"fields": ("role",)}),
        ("Permissions", {"fields": ("is_staff", "is_active", "is_superuser")}),
        ("Important Dates", {"fields": ("last_login", "date_joined")}),
    )

    add_fieldsets = (
        (None, {
            "classes": ("wide",),
            "fields": ("email", "password1", "password2", "role", "is_staff", "is_active"),
        }),
    )

    search_fields = ("email",)
    ordering = ("email",)

    def get_inlines(self, request, obj):
        if not obj:
            return []
        if obj.role == User.STUDENT:
            return [StudentProfileInline]
        if obj.role == User.TEACHER:
            return [TeacherProfileInline]
        if obj.role == User.ADMIN:
            return [AdminProfileInline]
        return []


admin.site.register(User, UserAdmin)
                    </pre>
                    <div class="Definitions">
                        In this modified admin.py file, we define inline classes for each profile model
                        (StudentProfileInline,
                        TeacherProfileInline, and AdminProfileInline) using admin.StackedInline. These inline classes
                        specify
                        how the profile information should be displayed within the User admin interface. <br>
                        We then create a custom UserAdmin class that extends BaseUserAdmin. In this class, we override
                        the
                        get_inlines method to return the appropriate inline class based on the user's role. This allows
                        us to
                        display the relevant profile information directly within the User admin interface. <br>
                        Finally, we register the custom UserAdmin class with the User model using admin.site.register.
                    </div>
                </section>
                <section id="Adding_Forms">
                    <h2 class="Section_Title">Adding Forms</h2>
                    <div class="Definitions">
                        The simplest way to build a form in Django is to use a ModelForm, which
                        uses the information from the models we defined earlier to automatically
                        build a form. <br>
                        Write your first form in the file forms.py, which you
                        should create in the same directory as models.py. <br>
                        Let's create a User registration form using the User model we defined earlier. <br>
                        This form will allow new users to sign up by providing their first name, last name,
                        email, and password and choosing their role (student, teacher, or admin). <br>
                        Open forms.py and add the following code:
                    </div>
                    <pre class="prettyprint python Code">
from django import forms
from .models import User

class UserRegistrationForm(forms.ModelForm):
    class Meta:
        model = User
        fields = ['first_name', 'last_name', 'email', 'password', 'role','phone']
        labels = {
            'first_name': 'First Name',
            'last_name': 'Last Name',
            'email': 'Email Address',
            'password': 'Password',
            'role': 'Role',
            'phone': 'Phone Number',
        }
        widgets = {
            'password': forms.PasswordInput(),
            'role': forms.Select(),
        }

    def save(self, commit=True):
            user = super().save(commit=False)
            user.set_password(self.cleaned_data["password"]) # Hash password
            if commit:
                user.save()
            return user

class LoginForm(forms.Form):
        email = forms.EmailField(label='Email Address')
        password = forms.CharField(label='Password', widget=forms.PasswordInput)
                    </pre>
                    <div class="Definitions">
                        This code creates a ModelForm named UserRegistrationForm that corresponds to the
                        User model. The fields attribute specifies which fields from the model should be included in
                        the form,
                        and the labels attribute provides human-readable labels for each field. <br>
                        The widgets attribute is used to customize the appearance of the password field, rendering it
                        as a
                        password input (hiding the characters as they are typed). <br>
                        The save method is overridden to hash the password before saving the user to the database.
                        First,
                        it calls the parent class's save method with commit=False to get an unsaved User instance.
                        Then, it sets the password using the set_password method, which hashes the password. Finally, if
                        commit is True, it saves the user to the database. <br>
                        Additionally, we define a simple LoginForm using forms.Form to handle user login with email and
                        password. <br>
                        Now, we need to add a URL pattern in urls.py to point to the view that will handle the form.
                        Let's call the view register_user, login_view, logout_view and add the following urlpatterns
                        list:
                    </div>
                    <pre class="prettyprint python Code">
from django.urls import path
from .views import login_view, logout_view, register_view

urlpatterns = [
    path("/login/", login_view, name="login"),
    path("/logout/", logout_view, name="logout"),
    path("/register/", register_view, name="register"),
]
</pre>
                    <div class="Definitions">
                        Next, we need to create the register_view view in views.py to handle the form submission and
                        rendering:
                    </div>
                    <pre class="prettyprint python Code">
def register_view(request):
    if request.method == "POST":
        form = UserRegistrationForm(request.POST, request.FILES)
        if form.is_valid():
            user = form.save()
            login(request, user)
            if user.role == User.STUDENT:
                return redirect("student_dashboard")
            elif user.role == User.TEACHER:
                return redirect("teacher_dashboard")
            elif user.role == User.ADMIN:
                return redirect("admin_dashboard")
        else:
            return render(request, "Home/register.html", {"form": form})
    else:
        form = UserRegistrationForm()
    return render(request, "Home/register.html", {"form": form})
                    </pre>
                    <div class="Definitions">
                        This view handles both GET and POST requests. If the request method is POST, it processes the
                        submitted form data. This is done by creating an instance of UserRegistrationForm with the
                        submitted data
                        and any uploaded files. <br>
                        It checks if the form is valid, and if so, it saves the new user to the database, logs them in,
                        and
                        redirects them to the appropriate dashboard based on their role. <br>
                        If the form is not valid, it re-renders the registration page with the form containing error
                        messages. <br>
                        login(request, user) logs the user in immediately after registration. <br>
                        If the request method is GET, meaning the user is accessing the page for the first time, it
                        simply
                        renders an empty form. <br>
                        The last line renders the register.html template, passing the form instance to the template
                        context. <br>
                        Finally, we need to create the register.html template to display the form:
                    </div>
                    <pre class="prettyprint html Code">
{% extends "Home/base_Home.html" %}
{% block content %}
&lt;h1&gt;User Registration&lt;/h1&gt;
&lt;form method="post" action="{% url 'register' %}"&gt;
    {% csrf_token %}
    {{ form.as_p }}
    &lt;button type="submit"&gt;Register&lt;/button&gt;
&lt;/form&gt;
{% endblock %}
                    </pre>
                    <div class="Definitions">
                        This template extends a base template named base_Home.html. <br>
                        Inside the content block, it displays a heading and a form. <br>
                        The form uses the POST method to submit data to the register_view. <br>
                        The {% csrf_token %} tag is included for security purposes to prevent Cross-Site Request Forgery
                        attacks. <br>
                        The {{ form.as_p }} renders the form fields as paragraphs, and a submit button is provided to
                        submit the form. <br>
                        Django doesn't create a submit button for forms, so we define one at the end of the form. <br>
                        With these components in place, users can now register new accounts through the web interface.
                        <br>
                        Now, we need to add a URL pattern in urls.py to point to the view that will
                        handle the form. Let's call the view register_student and add the following
                        urlpatterns list :
                    </div>
                    <pre class="prettyprint python Code">
......
    path('register/', views.register_student, name='register_student'),
......
                        </pre>

                </section>
                <section id="Login_Page">
                    <h2 class="Section_Title">Login Page</h2>
                    <div class="Definitions">
                        Next, we need to create the login_view and logout_view in views.py to handle the form submission
                        and
                        rendering:
                    </div>
                    <pre class="prettyprint python Code">
def login_view(request):
    if request.method == "POST":
    form = LoginForm(request.POST)
        if form.is_valid():
            email = form.cleaned_data['email']
            password = form.cleaned_data['password']
            user = authenticate(request, email=email, password=password)
            if user is not None:
                login(request, user)
                # Role-based redirect
                if user.role == user.STUDENT:
                    return redirect("student_dashboard")
                elif user.role == user.TEACHER:
                    return redirect("teacher_dashboard")
                elif user.role == user.ADMIN:
                    return redirect("admin_dashboard")
            else:
                messages.error(request, "Invalid email or password")
        else:
            messages.error(request, "Invalid email or password")
    else:
        form = LoginForm()
    return render(request, "Home/login.html", {"form": form})

def logout_view(request):
    logout(request)
    return redirect("login")
                    </pre>
                    <div class="Definitions">
                        The login_view handles both GET and POST requests. If the request method is POST, it processes
                        the
                        submitted login form data. <br>
                        It retrieves the email and password from the cleaned form data and uses Django's authenticate
                        function to verify the credentials. <br>
                        If the credentials are valid, it logs the user in and redirects them to the appropriate
                        dashboard. <br>
                        If the credentials are invalid, it displays an error message. <br>
                        If the request method is GET, it simply renders an empty login form. <br>
                        The logout_view logs the user out and redirects them to the login page. <br>
                        Finally, we need to create the login_student.html template to display the login form:
                    </div>
                    <pre class="prettyprint html Code">
{% extends "Home/base_Home.html" %}
{% block content %}
&lt;h1>Login&lt;/h1&gt;
&lt;form method="post" action="{% url 'login' %}"&gt;
    {% csrf_token %}
    {{ form.as_p }}
    &lt;button type="submit"&gt;Login&lt;/button&gt;
&lt;/form&gt;
{% if error %}
    &lt;p style="color: red;"&gt;{{ error }}&lt;/p&gt;
{% endif %}
{% endblock %}
                    </pre>
                    <div class="Definitions">
                        This template extends a base template named base_Home.html. <br>
                        Inside the content block, it displays a heading and a form. <br>
                        The form uses the POST method to submit data to the login_view. <br>
                        The {% csrf_token %} tag is included for security purposes to prevent Cross-Site Request
                        Forgery
                        attacks. <br>
                        The {{ form.as_p }} renders the form fields as paragraphs, and a submit button is provided to
                        submit the form. <br>
                        Additionally, if there is an error message (e.g., invalid credentials), it is displayed in red
                        below
                        the form. <br>
                        With these components in place, users can now log in to their accounts through the web
                        interface. <br>
                        Now, we need to add a URL pattern in urls.py to point to the login and logout views:
                    </div>
                    <pre class="prettyprint python Code">
......
    path("login/", login_view, name="login"),
    path("logout/", logout_view, name="logout"),
......
                    </pre>
                    <div class="Definitions">
                        Finally, we need to include a link to the login page in the navigation bar if the user is not
                        authenticated. Or display "Hello, [user.first_name]" and a logout link if the student is
                        authenticated. <br>
                        In the base_Home.html template to conditionally
                        display the login/signup links or the greeting and logout link:
                    </div>
                    <pre class="prettyprint html Code">
&lt;nav&gt;
    &lt;ul&gt;
        {% if request.user.first_name %}
            &lt;li&gt;Hello, {{ request.user.role}}: {{ request.user.first_name }}&lt;/li&gt;
            &lt;li&gt;&lt;a href="{% url 'logout' %}"&gt;Logout&lt;/a&gt;&lt;/li&gt;
        {% else %}
            &lt;li&gt;&lt;a href="{% url 'login_student' %}"&gt;Login&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href="{% url 'register_student' %}"&gt;Signup&lt;/a&gt;&lt;/li&gt;
        {% endif %}
    &lt;/ul&gt;
&lt;/nav&gt;
                    </pre>
                    <div class="Definitions">
                        This code checks if the user is authenticated by verifying if request.user.first_name exists.
                        If the user is authenticated, it displays a greeting with the user's first name and a logout
                        link. <br>
                        If the user is not authenticated, it displays links to the login and signup pages. <br>
                        With this setup, users can easily log in or sign up from the navigation bar, and authenticated
                        users
                        can log out when needed.
                    </div>
                </section>
                <section id="@login_required">
                    <h2 class="Section_Title">Restricting Access with @login_required</h2>
                    <div class="Definitions">
                        To restrict access to certain views based on user authentication, we can use the
                        @login_required
                        decorator provided by Django. <br>
                        A decorator is a directive placed just
                        before a function definition that Python applies to the function before it
                        runs to alter how the function code behaves. <br>
                        This decorator ensures that only authenticated users can access
                        the
                        decorated view. <br>
                        Here's how to use @login_required in your views.py file:
                    </div>
                    <pre class="prettyprint python Code">
from django.contrib.auth.decorators import login_required
@login_required
def student_dashboard(request):
    return render(request, "student/dashboard.html")
                    </pre>
                    <div class="Definitions">
                        In this example, the student_dashboard view is decorated with @login_required. This means that
                        only
                        users who are logged in can access this view. If an unauthenticated user tries to access the
                        view,
                        they will be redirected to the login page. <br>
                        You can apply the @login_required decorator to any view that you want to restrict access to
                        authenticated users only. <br>
                        Additionally, you can customize the login URL by setting the LOGIN_URL variable in your
                        settings.py
                        file:
                    </div>
                    <pre class="prettyprint python Code">
LOGIN_URL = '/Accounts/login/'
                    </pre>
                </section>
            </div>
        </div>
    </main>
</body>
<script src="../assets/JS/Nav_Bar.js" type="module"></script>
<script src="../assets/JS/Side_Bar.js" defer></script>
<script
    src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=c&amp;skin=sunburst"></script>


</html>